{
  parserClass = 'org.quiltmc.intellij.enigma.language.parser.EnigmaMappingParser'

  extends = 'com.intellij.extapi.psi.ASTWrapperPsiElement'

  psiClassPrefix = 'EnigmaMapping'
  psiImplClassSuffix = 'Impl'
  psiPackage = 'org.quiltmc.intellij.enigma.language.psi'
  psiImplPackage = 'org.quiltmc.intellij.enigma.language.psi.impl'

  elementTypeHolderClass = 'org.quiltmc.intellij.enigma.language.psi.EnigmaMappingTypes'
  elementTypeClass = 'org.quiltmc.intellij.enigma.language.psi.EnigmaMappingElementType'
  tokenTypeClass = 'org.quiltmc.intellij.enigma.language.psi.EnigmaMappingTokenType'

  parserUtilClass = 'org.quiltmc.intellij.enigma.language.parser.EnigmaMappingParserUtil'

  tokens = [
    NEW_LINE = "regexp:\r?\n"
    WHITE_SPACE = "regexp:[ ]+"
    TAB = "regexp:\t"

    CLASS_KEYWORD = "CLASS"
    FIELD_KEYWORD = "FIELD"
    METHOD_KEYWORD = "METHOD"
    ARG_KEYWORD = "ARG"
    COMMENT_KEYWORD = "COMMENT"

    ANY = "regexp:[^\r\n \t]+"
  ]
}

root ::= clazz ln* // validate any amount of trailing new lines

clazz ::= 'CLASS' binary-name [ binary-name ] class-children { pin=1 extends=entry }
private class-children ::= (ln ind comment)* (ln ind class-member)*
private class-member ::= field | method | clazz

field ::= 'FIELD' identifier [ identifier ] (ln ind comment)* { pin=1 extends=entry }

method ::= 'METHOD' identifier [ identifier ] (ln ind comment)* (ln ind arg)* { pin=1 extends=entry }

arg ::= 'ARG' (ln ind comment)* { pin=1 extends=entry }

comment ::= 'COMMENT' any* { pin=1 }

fake entry ::=

binary-name ::= (any '/')* any { pin(".*")=2 }
identifier ::= any

private ln ::= 'regexp:\r?\n'
private any ::= 'regexp:[^\r\n \t]+'
external ind ::= parseIndent
