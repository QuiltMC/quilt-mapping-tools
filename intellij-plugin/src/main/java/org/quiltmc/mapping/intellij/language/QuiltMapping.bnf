{
  parserClass = 'org.quiltmc.mapping.intellij.language.QuiltMappingParser'

  extends = 'com.intellij.extapi.psi.ASTWrapperPsiElement'

  psiClassPrefix = 'QuiltMapping'
  psiImplClassSuffix = 'Impl'
  psiPackage = 'org.quiltmc.mapping.intellij.language.psi'
  psiImplPackage = 'org.quiltmc.mapping.intellij.language.psi.impl'

  elementTypeHolderClass = 'org.quiltmc.mapping.intellij.language.psi.QuiltMappingTypes'
  elementTypeClass = 'org.quiltmc.mapping.intellij.language.psi.QuiltMappingElementType'
  tokenTypeClass = 'org.quiltmc.mapping.intellij.language.psi.QuiltMappingTokenType'

  tokens = [
    LCURLY='{'
    RCURLY='}'
    LBRACKET='['
    RBRACKET=']'

    COMMA=','
    COLON=':'
    COMMENT='regexp://.*'
    BLOCK_COMMENT='regexp:/\*([^*]|\*+[^*/])*(\*+/)?'
    // require escaped new lines
    DOUBLE_QUOTED_STRING="regexp:\"([^\"\n]|\\\n)*\"?"
    SINGLE_QUOTED_STRING="regexp:'([^'\n]|\\\n)*'?"

    // hexadecimal [-+]?0[xX]([A-Fa-f0-9]+)
    // decimal [-+]?(?=.?\d+)\d*\.?\d* - allow leading/trailing commas, ensure there's at least one digit (via lookahead)
    // with exponent [-+]?\d+[Ee][-+]?\d+
    NUMBER='regexp:[-+]?0[xX]([A-Fa-f0-9]+)|[-+]?(?=\.?\d+)\d*\.?\d*|[-+]?\d+[Ee][-+]?\d+'
    TRUE='true'
    FALSE='false'
    NULL='null'
    IDENTIFIER="regexp:\p{javaLetter}[\p{javaLetterOrDigit}_$]*"
    SPACE='regexp:\s'
  ]
}

root ::= object

// objects
object ::= '{' object_element* '}' {pin=1}
object_element ::= property (','|&'}') {recoverWhile=recover_object; pin=1}

// properties
property ::= property_name (':' property_value) {pin(".*")=1}
property_name ::= literal | reference_expression
property_value ::= value

// arrays
array ::= '[' array_element* ']' {pin=1}
array_element ::= value (','|&']') {recoverWhile=recover_array; pin=1}

// literals
string_literal ::= SINGLE_QUOTED_STRING | DOUBLE_QUOTED_STRING
number_literal ::= NUMBER
boolean_literal ::= TRUE | FALSE
null_literal ::= NULL

reference_expression ::= IDENTIFIER

literal ::= string_literal | number_literal | boolean_literal | null_literal

value ::= object | array | literal | reference_expression

// recoveries
private recover_object ::= !('}'|value)
private recover_array ::= !(']'|value)
